<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/util_basic.js | Public API | Meeks-PRF-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Count votes for a Meek&apos;s method RCV / STV election contest using the prfound.org reference rule, with optional extensions."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/DavidCary/Meeks-PRF-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ballot.js~Ballot.html">Ballot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9.html">Decimal9</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Error.html">Decimal9Error</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Total.html">Decimal9Total</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekImplementationError.html">MeekImplementationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekValueError.html">MeekValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meek.js~Tabulation.html">Tabulation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/progress.js~Progress.html">Progress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~Results.html">Results</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/status.js~Status.html">Status</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBaseError.html">UtilBaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBasicFunctions.html">UtilBasicFunctions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilValueError.html">UtilValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validate.js~Validator.html">Validator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/with_json.js~WithJson.html">WithJson</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tabulate">tabulate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-K">K</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UBF">UBF</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/util_basic.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @copyright 2016-2019 David Cary;
 * @license Apache-2.0
 *
 * @module UtilBasic
 * @summary Basic utility functions and classes
 *   without other module dependencies.
 */

/** A convenience class for exporting a collection of functions
 *  as static functions of the class.
 *
 *  This class is intended to be used for its static functions and is
 *  not expected to be instantiated.0
 */
export class UtilBasicFunctions {

  /** Create a multi-line description of an error and its traceback.
   * @param {Error} err - a caught exception.
   * @return {string} a multi-line string showing message and traceback
   *   of err. */
  static describeError(err) {
    return describeError(err);
  }

  /** Indent a possibly multi-line text string.
   *
   * @param {string} message - the message string to indent.
   * @param {number} [indentBy=2] - the number of spaces to indent each
   *   line of the message.
   * @return {string} a string with the indentations added to each line.
   */
  static indentMessage(message, indentBy=2) {
    return indentMessage(message, indentBy);
  }

  /**
   * Create an array of strings from a string or an array of strings.
   *
   * If value is a string, it is split by its first character,
   * and the resulting parts populate the array.
   *
   * If the value is the empty string, an empty array is returned.
   *
   * If value is a string of length 1, an array containing a single
   * empty string is returned.
   *
   * If value is an array of strings,
   * (either typeof &apos;string&apos; or instanceof String),
   * a copy of that array is returned,
   * with any Strings converted to items of typeof &apos;string&apos;.
   *
   * @param {string|array} value - A string that will be converted to an
   * array of strings, or an array that will be verified as only
   * containing strings.
   *
   * @return {array} An array of strings.
   *
   * @throws {UtilValueError} If value is not a string and is not an
   * array of strings.
   */
  static toArrayOfStrings(value) {
    return toArrayOfStrings(value);
  }

  /**
   * Get the class name of an instance object, if it is available.
   *
   * Look for the name property of the prototype&apos;s constructor.
   *
   * @param {Object} instance - A value;
   * @return {string} The found name or the empty string.
   */
  static getClassNameOf(instance) {
    return getClassNameOf(instance);
  }

  /**
   * Get an array of an object&apos;s enumerable property keys.
   *
   * Accomplish this with a traditional for in loop.
   * This can retrieve keys that are only in the prototype chain,
   * and can reflect gaps in an array&apos;s indexing.
   *
   * @param {Object} object - The object for which keys are retrieved.
   * @return {array&lt;string&gt;} An array of found keys.
   */
  static getKeys(object) {
    return getKeys(object);
  }

  /**
   * Get a sorted array of an object&apos;s enumerable property keys.
   *
   * Use &apos;getKeys()&apos; to retrieve the keys.
   *
   * For sorting, key strings that correspond to a decimal integer value
   * are converted to numbers and sorted in numeric order before any
   * string keys.  The numbers are converted back to strings before
   * returning the sorted array.
   * @param {Object} object - The object for which keys are retrieved.
   * @return {Array&lt;string&gt;} A sorted array of found keys.
   */
  static getSortedKeys(object) {
    return getSortedKeys(object);
  }

  /**
   * Get an array of names / keys of enumerable properties for an
   * object.
   *
   * The names are retrieved using a for-in loop.
   * @param {Object} object - The object for which names are retrieved.
   * @return {array} An array with the found property names / keys.
   */
  static getNames(object) {
    return getNames(object);
  }

  /**
   * Get an array of names and values for an object&apos;s enumerable
   * properties.
   *
   * Each entry in the array is an `ObjItem` instance.
   *
   * The names and values are retrieved with a for-in loop.
   * @param {Object} object - The object for which names and values are
   *   retrieved.
   * @return {array} An array with the found property data.
   */
  static getItems(object) {
    return getItems(object);
  }

  /**
   * Get an array of values for an object&apos;s enumerable properties.
   *
   * The values are retrieved with a for-in loop.
   * @param {Object} object - The object for which values are retrieved.
   * @return {array} An array with the found property values.
   */
  static getValues(object) {
    return getValues(object);
  }

  /**
   * Get an array of names / keys of own properties for an object.
   *
   * The names are retrieved using `Object.getOwnPropertyDescriptors()`.
   * @param {Object} object - The object for which names are retrieved.
   * @return {array} An array with the found property names / keys.
   * @throws {*} An error if Object.getOwnPropertyDescriptors() is not
   *   supported.
   */
  static getOwnNames(object) {
    return getOwnNames(object);
  }

  /**
   * Get an array of names and values of own properties for an object.
   *
   * The data is retrieved using `Object.getOwnPropertyDescriptors()`.
   * @param {Object} object - The object for which data are retrieved.
   * @return {array} An array with the found names and values.
   *   Each array entry is an instance of `ObjItem`.
   * @throws {*} An error if Object.getOwnPropertyDescriptors() is not
   *   supported.
   */
  static getOwnItems(object) {
    return getOwnItems(object);
  }

  /**
   * Get an array of values of own properties for an object.
   *
   * The values are retrieved using `Object.getOwnPropertyDescriptors()`.
   * @param {Object} object - The object for which values are retrieved.
   * @return {array} An array with the found values.
   *   Each array entry is an instance of `ObjItem`.
   * @throws {*} An error if Object.getOwnPropertyDescriptors() is not
   *   supported.
   */
  static getOwnValues(object) {
    return getOwnValues(object);
  }

  /** Create a string representation of a Javascript value.
   *
   * The value can be a primitive or an object.
   * Support for data objects, arrays, and sets is provided.
   *
   * Currently there is no use of the `options` and `showClasses`
   * parameters.
   *
   * @param {*} value - A value to be converted to a string.
   * @param {Object} options - A data object with options for
   *   converting to and formatting of the string.
   * @param {array&lt;ShowClass&gt;} showClasses - Per class customizations
   *   for how the value should be converted and how the string
   *   should be formatted.
   * @return {string} A string representing the value.
   */
  static show(value, options, showClasses) {
    const result = _show.show(value, options, showClasses);
    return result;
  }

  /**
   * Produce the set union of two iterables.
   *
   * @param {iterable} iterable1 - An iterable object such as an array,
   *   set, or other object.
   * @param {iterable} iterable2 - An iterable object such as an array,
   *   set, or other object.
   * @return {Set} A set with the union of the iterated values.
   * For object arguments, the set contains their keys.
   */
  static setUnion(iterable1, iterable2) {
    return setUnion(iterable1, iterable2);
  }

  /**
   * Produce the set intersection of two iterables.
   *
   * @param {iterable} iterable1 - An iterable object such as an array,
   *   set, or other object.
   * @param {iterable} iterable2 - An iterable object such as an array,
   *   set, or other object.
   * @return {Set} A set with the intersection of the iterated values.
   * For object arguments, the set contains their keys.
   */
  static setIntersection(iterable1, iterable2) {
    return setIntersection(iterable1, iterable2);
  }

  /**
   * Produce the set difference of two iterables.
   *
   * @param {iterable} iterable1 - An iterable object such as an array,
   *   set, or other object.
   * @param {iterable} iterable2 - An iterable object such as an array,
   *   set, or other object.
   * @return {Set} A set with difference of the iterated values,
   *   all of the items in iterable1 that are not in iterable2.
   * For object arguments, the set contains their keys.
   */
  static setDifference(iterable1, iterable2) {
    return setDifference(iterable1, iterable2);
  }
}

/**
 * An alias for the `UtilBasicFunctions` class,
 * which provides various functions as static class
 * functions for general use. */
export const UBF = UtilBasicFunctions;


/** A base class for thrown errors.
 */
export class UtilBaseError extends Error {
  /**
   * @param {string} [message=&apos;ERROR&apos;] - text describing the error.
   * @param {array} [otherValues=[]] - an array of values,
   *   each value is typically a two-element array as [description, value].
   *   Other kinds of values are possible, however.
   * @param {Error|null} [priorError=null] - an error of some type that was the
   *   cause for this error being formed. */
  constructor(message=&apos;ERROR&apos;, otherValues=[], priorError=null) {
    super(message);
    /** The message for this error.
     * @type {string} */
    this.message = String(message);
    /** Other values associated with this error and which document additional
     *    context surrounding the error.
     * @type {array} */
    this.otherValues = otherValues;
    /** The prior error that was a direct cause for this error.
     * @type {Error|null} */
    this.priorError = priorError;
    /** A fuller description of the prior error, created using describeError().
     * @type(string) */
    this.priorErrorDescription = &apos;&apos;;
    if (this.priorError !== null &amp;&amp;
          this.priorError instanceof Error) {
      this.priorErrorDescription = describeError(this.priorError)
    }
    /** The name of the class of this error.
     * @type{string} */
    this.name = getClassNameOf(this);
  }

  _showPriorError() {
    // Select what to show about the priorError.
    return this.priorError.toString();
  }

  /** Convert to a string
   * @return {string} a string representing the error&apos;s message,
   *   its otherValues, and its priorError, if any. */
  toString() {
    let result = [this.name + (this.message ? &apos;: &apos; + this.message : &apos;&apos;)];
    if (this.otherValues.length) {
      result.push(this._otherValuesAsStr(this.otherValues));
    }
    if (this.priorError) {
      result.push(&apos;  Prior error:&apos;);
      result.push(indentMessage(this._showPriorError(), 4));
    }
    result = result.join(&apos;\n&apos;);
    return result;
  }

  _otherValuesAsStr(otherValues, indentBy=2) {
    const limit = 200;
    let result = [];
    if (otherValues instanceof Array) {
      this.otherValues.forEach((valueItem, ix) =&gt; {
        if (valueItem instanceof Array &amp;&amp; valueItem.length === 2) {
          let line = String(valueItem[0]).padEnd(25) + &apos; = &apos;;
          const showValue = UBF.show(valueItem[1]);
          const value = truncateString(showValue, limit);
          line += value;
          result.push(line);
        } else {
          const showValue = UBF.show(valueItem);
          const value = truncateString(showValue, limit);
          result.push(value);
        }
      });
    } else {
      const showValue = UBF.show(otherValues);
      const value = truncateString(otherValues, limit);
      result.push(value);
    }
    result = result.join(&apos;\n&apos;);
    result = indentMessage(result, indentBy);
    return result;
  }
}

/** This function is used by UtilBaseError to limit how long
 * a displayed value can be from otherValues. */
function truncateString(value, limit=40) {
  if (typeof value != &apos;string&apos;) {
    value = String(value);
  }
  if (!limit || !Number.isInteger(limit) || limit &lt; 0) {
    limit = 10;
  }
  if (value.length &gt; limit) {
    value = value.slice(0, limit);
    if (value.length &amp;&amp; value[0] === &apos;&quot;&apos;) {
      value += &apos;&quot;&apos;;
    }
    value = &apos;(only first &apos; + limit + &apos; chars): &apos; + value +
          &apos; + more ...&apos;;
  }
  return value;
}


/** An error class for invalid data values and types.
 */
export class UtilValueError extends UtilBaseError {
  /** The calling convention is the same as for UtilBaseError. */
  constructor(message, otherValues=[], priorError=null) {
    super(message, otherValues, priorError);
  }
}

/** See the corresponding UtilBasicFunction method. */
function describeError(err) {
  //&quot;&quot;&quot;
  const parts = [];
  parts.push(&apos;Error description:&apos;);
  parts.push(indentMessage(err.toString()));
  if (err.stack) {
    parts.push(&apos;Error stack:&apos;);
    parts.push(indentMessage(err.stack.toString()));
  } else {
    parts.push(`  ${err.toString()}:`);
  }
  if (err.priorError) {
    parts.push(&apos;Prior Error:&apos;);
    parts.push(indentMessage(describeError(err.priorError), 2));
  }
  parts.push(&apos;END Error description&apos;);
  const result = parts.join(&quot;\n&quot;);
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function indentMessage(message, indentBy=2) {
  const indentStr = &apos; &apos;.repeat(indentBy);
  let tail = &apos;&apos;;
  let mainMessage = message.toString();
  //console.log(&apos;typeof mainMessage=&apos;+typeof mainMessage);
  //console.log(&apos;mainMessage.valueOf()=&apos;+mainMessage.valueOf());
  if (mainMessage &amp;&amp; mainMessage.slice(-1) === &apos;\n&apos;) {
    tail = &apos;\n&apos;;
    mainMessage = message.slice(0,-1);
  }
  const newMessage = (
        indentStr + mainMessage.replace(/\n/g, &apos;\n&apos; + indentStr) + tail);
  return newMessage;
}

/** See the corresponding UtilBasicFunction method. */
function toArrayOfStrings(value) {
  if (typeof value == &apos;string&apos; || value instanceof String) {
    if (value.length) {
      const result = value.slice(1).split(value[0]);
      return result;
    } else {
      return [];
    }
  } else if (Array.isArray(value)) {
    const result = [];
    // for loop, instead of forEach, used to detect skipped/undefined values
    for (let ix = 0; ix &lt; value.length; ix++) {
      const item = value[ix];
      if (typeof item == &apos;string&apos; || item instanceof String) {
        result.push(String(item));
        continue;
      }
      throw new UtilValueError(&apos;Array has an item that is not a string:&apos;, [
            [&apos;item position&apos;, ix + 1],
            [&apos;typeof item&apos;, typeof item],
            [&apos;item&apos;, item],
            [&apos;array length&apos;, value.length],
      ]);
    }
    return result;
  }
  throw new UtilValueError(&apos;Value is not a string or array:&apos;, [
        [&apos;typeof value&apos;, typeof value],
        [&apos;value&apos;, value],
  ]);
}

/** See the corresponding UtilBasicFunction method. */
function getClassNameOf(instance) {
  let result = &apos;&apos;;
  if (typeof instance != &apos;object&apos; || instance === null) {
    return result;
  }
  const prototype = Object.getPrototypeOf(instance);
  if (&apos;constructor&apos; in prototype &amp;&amp; &apos;name&apos; in prototype.constructor) {
    result = prototype.constructor.name;
    if (typeof result == &apos;string&apos;) {
      return result;
    }
  }
  return &apos;&apos;;
}

/** See the corresponding UtilBasicFunction method. */
function getKeys(object) {
  const result = [];
  try {
    for (let x in object) {
      result.push(x);
    }
  } catch (exc) { }
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function getSortedKeys(object) {
  let result = getKeys(object);
  if (result.length) {
    result = result.map(key =&gt;
      typeof key == &apos;string&apos; &amp;&amp; key.match(/^(\+|-)?[0-9]+$/) ?
            parseInt(key) : key
    );
    result.sort((a, b) =&gt; {
      let comparison = 2;
      if (typeof a == &apos;number&apos;) {
        comparison = typeof b == &apos;number&apos; ? (a &lt; b ? -1 : a &gt; b ? 1 : 0) : -1;
      } else if (typeof a == &apos;string&apos;) {
        if (typeof b == &apos;string&apos;) {
          comparison = a &lt; b ? -1 : a &gt; b ? 1 : 0;
        } else {
          comparison = typeof b == &apos;number&apos; ? 1 : -1;
        }
      } else if (typeof b == &apos;symbol&apos;) {
        comparison = 0;
      } else {
        comparison = 1;
      }
      return comparison;
    });
    result = result.map(
      key =&gt; typeof key == &apos;number&apos; ? String(key) : key
    );
  }
  return result;
}

// a regexp for a decimal, possibly infinite number that is not a NaN:
//     /^(+|-)?(Infinity)|(([0-9]+(\.[0-9]*)?)|(\.[0-9]+)(e(+|-)[0-9]+))$/
// a regexp for a decimal, non-negative array index
//     /^[0-9]+$/
// a regexp for a decimial integer
//     /^(+|-)[0-9]+$/
//export usort(array)
/*
class USort {
  static sort(array) {
    if (!Array.isArray(array)) {
*/

/**
 * A helper class for the `Show` class that will be used to provide
 * custom formatting and parsing for a particular class.
 *
 * This is not yet actively used.
 */
class ShowClass {
  constructor(classType, showFunction, options={}) {
    this.classType = classType;
    this.showFunction = showFunction;
    this.options = options;
  }
}

/**
 * A helper class for the `Show` class that is used to internally
 * represent intermediate results.
 *
 * This is not expected to be used as part of the public interface.
 */
class _ShowParts {
  constructor(content=&apos;&apos;, name=&apos;&apos;, head=&apos;&apos;, tail=&apos;&apos;, separator=&apos;, &apos;) {
    this.content = content;
    this.name = name;
    this.head = head;
    this.tail = tail;
    this.separator = separator;
    if (this.name === &apos;Object&apos; &amp;&amp; Array.isArray(this.content) &amp;&amp;
          this.head === &apos;{&apos; &amp;&amp; this.tail === &apos;}&apos;) {
      this.name = &apos;&apos;;
    }
  }

  get length() {
    let result = this.name.length + this.head.length + this.tail.length;
    if (this.name.length) {
      result += 2;
    }
    if (typeof this.content == &apos;string&apos;) {
      result += this.content.length;
    } else if (Array.isArray(this.content)) {
      this.content.forEach((content_item, ix) =&gt; {
        result += content_item.length + (ix &gt; 0 ? this.separator.length : 0);
      });
    }
    return result;
  }

  push(item) {
    if (typeof this.content == &apos;string&apos;) {
      this.content += String(item);
    } else if (Array.isArray(this.content)) {
      this.content.push(String(item));
    }
    return this;
  }

  compose() {
    let result = &apos;&apos;;
    if (this.name.length) {
      result += &apos;@&apos; + this.name + &apos;:&apos;;
    }
    result += this.head;
    if (typeof this.content == &apos;string&apos;) {
      result += this.content;
    } else if (Array.isArray(this.content)) {
      result += this.content.join(this.separator);
    }
    result += this.tail;
    return result;
  }
}

/**
 * A class for creating string representations of primitive values
 * and objects, using an extensible mechanism for custom handling
 * of various types of objects.
 *
 * Current support handles all standard primitive types except for
 * Symbols, for Arrays and Sets, and for other objects generally.
 */
class Show {
  constructor(options={}, showClasses=[]) {
    this.options = options;
    this.showClasses = showClasses;
  }
  show(value, options={}, showClasses=[]) {
    const useOptions = Object.assign({}, this.options, options);
    const useShowClasses = showClasses.concat(this.showClasses);
    const result = this._compose(value, useOptions, useShowClasses);
    return result;
  }

  _compose(value, options, showClasses) {
    const parts = this._decompose(value, options, showClasses);
    const formatted = this._formatParts(parts, value, options, showClasses);
    const result = formatted.compose();
    return result;
  }

  _formatParts(parts, value, options, showClasses) {
    return parts;
  }

  _decompose(value, options, showClasses) {
    if (typeof value === &apos;string&apos;) {
      const value2 = value
            .replace(/\\/g, &apos;\\\\&apos;)
            .replace(/&quot;/g, &apos;\\&quot;&apos;)
            .replace(/\n/g, &apos;\\n&apos;)
            .replace(/\t/g, &apos;\\t&apos;)
            .replace(/\r/g, &apos;\\r&apos;)
      ;
      const parts = new _ShowParts(value2, &apos;&apos;, &apos;&quot;&apos;, &apos;&quot;&apos;);
      return parts;
    }
    if (typeof value === &apos;number&apos;) {
      return new _ShowParts(String(value));
    }
    if (typeof value === &apos;undefined&apos;) {
      return new _ShowParts(&apos;undefined&apos;);
    }
    if (value === null) {
      return new _ShowParts(&apos;null&apos;);
    }
    if (Array.isArray(value)) {
      const parts = new _ShowParts([], &apos;&apos;, &apos;[&apos;, &apos;]&apos;);
      let nextIndex = 0;
      getKeys(value).forEach(value_index =&gt; {
        const index = Number(value_index);
        if (Number.isInteger(index) &amp;&amp; index &gt;= 0 &amp;&amp;
              index &lt; Number.MAX_SAFE_INTEGER) {
          if (index &gt; nextIndex) {
            parts.push(&apos;&lt;skip &apos;+(index - nextIndex)+&apos;&gt;&apos;);
            nextIndex = index;
          }
          parts.push(this._compose(value[value_index], options, showClasses));
          nextIndex = index + 1;
        }
      });
      return parts;
    }
//    if (value instanceof K.Decimal &amp;&amp; !options.decimal9AsObject) {
//      return new _ShowParts(value.toString());
//    }
    if (value instanceof Set) {
      const parts = new _ShowParts(this._compose(Array.from(value)), &apos;Set&apos;);
      return parts;
    }
    if (typeof value === &apos;boolean&apos;) {
      return  new _ShowParts(String(value));
    }
    if (typeof value === &apos;function&apos;) {
      return new _ShowParts(&apos;&lt;function&gt;&apos;);
    }
    /*
    if (typeof value === &apos;bigint&apos;) {
      const result = value.toString();
      return result;
    }
    */
    if (typeof value === &apos;object&apos;) {
      const parts = new _ShowParts([], getClassNameOf(value), &apos;{&apos;, &apos;}&apos;);
      getSortedKeys(value).forEach((value_key, ix) =&gt; {
        parts.push(this._compose(String(value_key), options, showClasses) +
              &apos;: &apos; + this._compose(value[value_key], options, showClasses));
      });
      return parts;
    }
    return &apos;&lt;unknown&gt;&apos;;
  }
}

/**
 * An instance of the `Show` class which has its `show()` method
 * exposed as a static method of the `UtilBasicFunctions` class.
 */
const _show = Object.freeze(new Show());

/**
 * A class representing the name and value of an object property.
 */
class ObjItem {
  /**
   * @param {string|symbol} The name / key of the property.
   * @param {*} The value of the property.
   */
  constructor(name, value) {
    /** The name of the property, either a string or a symbol.
     * @type {string|symbol} */
    this.name = name;
    /** The value of the property.
     * @type {*} */
    this.value = value;
  }

  /**
   * Produce a string representation of the name and value,
   * mimicking the format of an object literal.
   * @return {string} A string representation of the key and value.
   */
  toString() {
    const result=&apos;{name: &quot;&apos;+String(this.name)+&apos;&quot;, value: &apos;+
          (typeof this.value === &apos;string&apos; ?
          &apos;&quot;&apos;+this.value+&apos;&quot;&apos; : this.value.valueOf()) +&apos;}&apos;;
    return result;
  }
}

/** See the corresponding UtilBasicFunction method. */
function getNames(object) {
  const result = [];
  for (let name in object) {
    result.push(String(name));
  }
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function getItems(object) {
  const result = [];
  for (let name in object) {
    const value = object[name];
    result.push(new ObjItem(name, value));
  }
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function getValues(object) {
  const result = [];
  getItems(object).forEach((item) =&gt; {
    result.push(item.value);
  });
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function getOwnNames(object) {
  const result = [];
  let descriptors = {}
  try {
    descriptors = Object.getOwnPropertyDescriptors(object);
  }
  catch (exc) {
    console.error(&apos;Error: Unsupported Object.getOwnPropertyDescriptors()&apos;);
    console.error(&apos;  error message=&quot;&apos;+exc.toString()+&apos;&quot;&apos;);
    console.error(&apos;Error description:\n&apos;+describeError(exc));
    throw exc;
  }
  for (let name in descriptors) {
    const descriptor = descriptors[name];
    if (descriptor.enumerable) {
      result.push(name);
    }
  }
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function getOwnItems(object) {
  const result = [];
  let descriptors = {}
  try {
    descriptors = Object.getOwnPropertyDescriptors(object);
  }
  catch (exc) {
    console.error(&apos;Error: Unsupported Object.getOwnPropertyDescriptors()&apos;);
    console.error(&apos;  error message=&quot;&apos;+exc.toString()+&apos;&quot;&apos;);
    console.error(&apos;Error description:\n&apos;+describeError(exc));
    throw exc;
  }
  for (let name in descriptors) {
    const descriptor = descriptors[name];
    if (descriptor.enumerable) {
      result.push(new ObjItem(name, descriptor.value));
    }
  }
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function _getOwnValues(object) {
  const result = [];
  getOwnItems(object).forEach((item) =&gt; {
    result.push(item.value);
  });
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function setUnion(iterable1, iterable2) {
  const result = new Set(iterable1);
  iterable2.forEach((item) =&gt; {
    result.add(item);
  });
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function setIntersection(iterable1, iterable2) {
  const base = new Set(iterable2);
  const result = new Set();
  iterable1.forEach((item) =&gt; {
    if (base.has(item)) {
      result.add(item);
    }
  });
  return result;
}

/** See the corresponding UtilBasicFunction method. */
function setDifference(iterable1, iterable2) {
  const result = new Set(iterable1);
  iterable2.forEach((item) =&gt; {
    result.delete(item);
  });
  return result;
}


</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
