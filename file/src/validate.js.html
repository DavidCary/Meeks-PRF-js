<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/validate.js | Public API | Meeks-PRF-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Count votes for a Meek&apos;s method RCV / STV election contest using the prfound.org reference rule, with optional extensions."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/DavidCary/Meeks-PRF-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ballot.js~Ballot.html">Ballot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9.html">Decimal9</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Error.html">Decimal9Error</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Total.html">Decimal9Total</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekImplementationError.html">MeekImplementationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekValueError.html">MeekValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meek.js~Tabulation.html">Tabulation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/progress.js~Progress.html">Progress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~Results.html">Results</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/status.js~Status.html">Status</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBaseError.html">UtilBaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBasicFunctions.html">UtilBasicFunctions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilValueError.html">UtilValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validate.js~Validator.html">Validator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/with_json.js~WithJson.html">WithJson</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tabulate">tabulate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-K">K</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UBF">UBF</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/validate.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @copyright 2016-2019 David Cary;
 * @license Apache-2.0
 *
 * @module Validate
 */

import K from &apos;./constants.js&apos;;
import {MeekValueError} from &apos;./errors.js&apos;;
import {UBF, UtilValueError} from &apos;./util_basic.js&apos;;
import {Ballot} from &apos;./ballot.js&apos;;

/**
 * A collection of validation and reformatting methods for Meek data.
 *
 * See the description of parameters for the Tabulation() constructor
 * for details about the requirements for those values, which are enforced
 * here.
 */
export class Validator  {

  /**
   * A test for being a safe integer, which accepts number values
   * @param {*} value - A value to be tested whether it is a safe integer.
   * @returns {boolean} The indication of whether the tested value is a safe
   * integer.
   */
  static isSafeInteger(value) {
    if (typeof value == &apos;number&apos; &amp;&amp; Number.isInteger(value)) {
      if (Math.trunc(value) === value) {
        const maxSafeInteger = K.Decimal.MAX_SAFE_VALUE;
        if (value &gt;= -maxSafeInteger &amp;&amp; value &lt;= maxSafeInteger) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Create an array of strings from a string or an array of strings.
   *
   * If value is a string, it is split by its first character,
   * and the resulting parts populate the array.
   *
   * If value is an array of strings,
   * (either typeof &apos;string&apos; or instanceof String),
   * a copy of that array is returned,
   * with any Strings converted to items of typeof &apos;string&apos;.
   *
   * This function is a wrapper function for
   * `UtilBasicFunctions.toArrayOFStrings()`, and ensures that any
   * validation error that is thrown is of type MeekValueError.
   *
   * @param {string|array} value - A string that will be converted to an array
   * of strings, or an array that will be verified as only containing strings
   * and then duplicated.
   *
   * @return {array} An array of strings.
   *
   * @throws {MeekValueError} If value is not a string and is not an array of
   * strings.
   */
  static toArrayOfStrings(value) {
    let result = &apos;&apos;;
    try {
      result = UBF.toArrayOfStrings(value);
    } catch (exc) {
      if (exc instanceof UtilValueError) {
        const newErr = new MeekValueError(exc.message, exc.otherValues);
        throw newErr;
      }
      throw exc;
    }
    return result;
  }


  /**
   * Validate a number of seats to fill.
   * @param {number} nbrSeatsToFill - The number to validate.
   * @return {number} nbrSeatsToFill if it was valid.
   * @throw {MeekValueError} If nbrSeatsToFill was not valid.
   */
  nbrSeatsToFill(nbrSeatsToFill) {
    if (!Validator.isSafeInteger(nbrSeatsToFill)) {
      throw new MeekValueError(&apos;nbrSeatsToFill is not a safe integer:&apos;, [
            [&apos;typeof nbrSeatsToFill&apos;, typeof nbrSeatsToFill],
            [&apos;nbrSeatsToFill is a Number?&apos;, nbrSeatsToFill instanceof Number],
            [&apos;nbrSeatsToFill&apos;, nbrSeatsToFill]
      ]);
    }
    nbrSeatsToFill = Number(nbrSeatsToFill);
    if (nbrSeatsToFill &lt;= 0) {
      throw new MeekValueError(&apos;nbrSeatsToFill is less than 1:&apos;, [
            [&apos;nbrSeatsToFill&apos;, nbrSeatsToFill],
      ]);
    }
    return nbrSeatsToFill;
  }

  /** Validate a list of candidate identifiers.
   * @param {string|array&lt;string&gt;} candidates - A proposed value.
   * @return {array&lt;string&gt;} candidates if it was valid.
   * @throw {MeekValueError} If candidates was not valid.
   */
  candidates(candidates) {
    try {
      candidates = Validator.toArrayOfStrings(candidates);
    }
    catch (exc) {
      throw new MeekValueError(&apos;Invalid candidates type:&apos;, [], exc);
    }
    const candidateIndexes = {};
    candidates.forEach((candId, ix) =&gt; {
      if (!candId.length ||  K.RANKING_CODES_NOT_A_CANDIDATE.has(candId) ||
            candId[0] === &apos;:&apos;) {
        throw new MeekValueError(
              &apos;Invalid candidate ID in list of candidates:&apos;, [
              [&apos;candidate id&apos;, candId],
              [&apos;list position&apos;, ix + 1],
        ]);
      }
      if (typeof candidateIndexes[candId] == &apos;number&apos;) {
        throw new MeekValueError(
              &apos;Duplicate candidate ID in list of candidates:&apos;, [
              [&apos;candidate id&apos;, candId],
              [&apos;first list position&apos;, candidateIndexes[candId]],
              [&apos;next list position&apos;, ix + 1],
        ]);
      }
      candidateIndexes[candId] = ix + 1;
    });
    return candidates;
  }

  /**
   * Validate a tieBreaker list of candidate identifiers.
   * @param {string|array&lt;string&gt;} tieBreaker - A proposed value.
   * @param {array&lt;string&gt;} candidates - A validated array of ranking codes.
   * @return {object} tieBreaker as an object keyed by candidate IDs
   *   and values equal to ordering indexes.
   * @throw {MeekValueError} If tieBreaker was not valid.
   */
  tieBreaker(tieBreaker, candidates) {
    try {
      tieBreaker = Validator.toArrayOfStrings(tieBreaker);
    }
    catch (exc) {
      throw new MeekValueError(&apos;Invalid tieBreaker type:&apos;, [], exc);
    }
    tieBreaker.forEach((candId, ix) =&gt; {
      if (candidates.indexOf(candId) === -1) {
        throw new MeekValueError(&apos;Invalid candidate ID in tieBreaker:&apos;, [
              [&apos;candidate candId&apos;, candId],
              [&apos;tieBreaker list position&apos;, ix + 1],
        ]);
      }
    });
    const result = {};
    const tieBreakerSet = new Set();
    tieBreaker.forEach((candId, ix) =&gt; {
      if (typeof result[candId] == &apos;number&apos;) {
        throw new MeekValueError(
              &apos;Duplicate candidate ID in tieBreaker:&apos;, [
              [&apos;candidate id&apos;, candId],
              [&apos;first list position&apos;, result[candId] + 1],
              [&apos;next list position&apos;, ix + 1],
        ]);
      }
      result[candId] = ix;
      tieBreakerSet.add(candId);
    });
    return result;
  }

  /**
   * Validate an array of ballots.
   * @param {array&lt;string|array&gt;} ballots - A proposed value.
   * @param {array&lt;string&gt;} candidates - A validated array of ranking codes.
   * @param {number|null} maxRankingLevels - A validated value.
   * @param {Progress} progress - To report progress via callback.
   * @return {array&lt;Ballot&gt;} An array of Ballot objects.
   * @throw {MeekValueError} If ballots was not valid.
   */
  ballots(ballots, candidates, maxRankingLevels, progress) {
    const result = [];
    if (!Array.isArray(ballots)) {
      throw new MeekValueError(&apos;ballots is not an array:&apos;, [
            [&apos;typeof ballots&apos;, typeof ballots],
            [&apos;ballots&apos;, ballots],
      ]);
    }
    let absoluteTotalNbrBallots = 0;
    ballots.forEach((ballot, ix) =&gt; {
      let multiple = 1;
      let rankings = [];
      if (typeof ballot == &apos;string&apos;) {
        rankings = ballot;
      } else if (Array.isArray(ballot) &amp;&amp;
            (ballot.length == 0 || typeof ballot[0] == &apos;string&apos;)) {
        rankings = ballot;
      } else {
        if (!Array.isArray(ballot)) {
          throw new MeekValueError(&apos;A ballot is not an array nor a string:&apos;, [
                [&apos;typeof ballot&apos;, typeof ballot],
                [&apos;ballot&apos;, ballot],
                [&apos;ballot nbr&apos;, ix + 1],
          ]);
        }
        if (ballot.length !== 2) {
          throw new MeekValueError(&apos;A ballot is not a pair of values:&apos;, [
                [&apos;ballot.length&apos;, ballot.length],
                [&apos;ballot&apos;, ballot],
                [&apos;ballot nbr&apos;, ix + 1],
          ]);
        }
        multiple = ballot[0];
        rankings = ballot[1];
      }
      if (!Validator.isSafeInteger(multiple)) {
        throw new MeekValueError(&apos;A ballot multiple is not a safe integer:&apos;, [
              [&apos;type(multiple)&apos;, typeof multiple],
              [&apos;multiple&apos;, multiple],
              [&apos;ballot nbr&apos;, ix + 1],
        ]);
      }
      multiple = Number(multiple);
      if (multiple &lt; 1) {
        throw new MeekValueError(&apos;A ballot multiple is zero or less:&apos;, [
              [&apos;multiple&apos;, multiple],
              [&apos;ballot nbr&apos;, ix + 1],
        ]);
      }
      try {
        rankings = Validator.toArrayOfStrings(rankings);
      }
      catch (exc) {
        throw new MeekValueError(&apos;Invalid ballot rankings type:&apos;, [
              [&apos;ballot nbr&apos;, ix + 1],
              ], exc);
      }
      if (maxRankingLevels !== null &amp;&amp;
            rankings.length &gt; maxRankingLevels) {
        throw new MeekValueError(&apos;Ballot rankings is too long:&apos;, [
              [&apos;rankings.length&apos;, rankings.length],
              [&apos;maxRankingLevels&apos;, maxRankingLevels],
              [&apos;ballot nbr&apos;, ix + 1],
        ]);
      }
      rankings.forEach((rankingCode, rix) =&gt; {
        if (candidates.indexOf(rankingCode) === -1 &amp;&amp;
              !K.RANKING_CODES_NOT_A_CANDIDATE.has(rankingCode)) {
          throw new MeekValueError(&apos;Invalid ballot ranking code:&apos;, [
                [&apos;ranking code&apos;, rankingCode],
                [&apos;ballot nbr&apos;, ix + 1],
                [&apos;ranking code position&apos;, rix + 1],
          ]);
        }
      });
      const internalBallot = new Ballot(multiple, rankings);
      absoluteTotalNbrBallots += Math.abs(multiple);
      result.push(internalBallot);
      if (progress &amp;&amp; (ix + 1) % progress.validationPeriod === 0) {
        progress.setValidationProgress(ix + 1);
      }
    });
    if (result.length !== ballots.length) {
      throw new MeekValueError(&apos;Ballots contains undefined items:&apos;, [
            [&apos;ballots.length&apos;, ballots.length],
            [&apos;number of validated ballots&apos;, result.length],
      ]);
    }
    if (!Validator.isSafeInteger(absoluteTotalNbrBallots)) {
      throw new MeekValueError(&apos;The absolute total number of ballots&apos;+
            &apos; is not a safe integer:&apos;, [
            [&apos;typeof total nbr ballots)&apos;, typeof absoluteTotalNbrBallots],
            [&apos;total nbr ballots&apos;, absoluteTotalNbrBallots],
            [&apos;max safe integer&apos;, K.Decimal.MAX_SAFE_VALUE],
      ]);
    }
    if (progress) {
      progress.setValidationProgress(progress.completedLabel);
    }
    return result;
  }

  /**
   * Validate maxRankingLevels.
   * @param {number|null} maxRankingLevels - A proposed value.
   * @return {number|null} A valid maxRankingLevels.
   * @throw {MeekValueError} If maxRankingLevels was not valid.
   */
  maxRankingLevels(maxRankingLevels) {
    if (maxRankingLevels === null) {
      return null;
    }
    if (!Validator.isSafeInteger(maxRankingLevels)) {
      throw new MeekValueError(&apos;maxRankingLevels is not a safe integer:&apos;, [
            [&apos;typeof maxRankingLevels&apos;, typeof maxRankingLevels],
            [&apos;maxRankingLevels&apos;, maxRankingLevels],
      ]);
    }
    maxRankingLevels = Number(maxRankingLevels);
    if (maxRankingLevels &lt; K.MIN_RANKINGS_SUPPORTED) {
      throw new MeekValueError(&apos;maxRankingLevels is less than &apos; +
            K.MIN_RANKINGS_SUPPORTED + &apos;:&apos;, [
            [&apos;maxRankingLevels&apos;, maxRankingLevels],
      ]);
    }
    return maxRankingLevels;
  }

  /**
   * Validate a list of excluded candidates.
   * @param {string|array&lt;string&gt;} excluded - A proposed value.
   * @param {array&lt;string&gt;} candidates - A validated array of candidate IDs.
   * @return {Set&lt;string&gt;} A set of excluded candidate IDs.
   * @throw {MeekValueError} If excluded was not valid.
   */
  excluded(excluded, candidates) {
    if (excluded === null) {
      excluded = [];
    }
    try {
      excluded = Validator.toArrayOfStrings(excluded);
    }
    catch (exc) {
      throw new MeekValueError(&apos;Invalid excluded type:&apos;, [], exc);
    }
    const result = new Set();
    const candidateIndexes = {};
    excluded.forEach((candId, ix) =&gt; {
      if (candidates.indexOf(candId) === -1) {
        throw new MeekValueError(&apos;Invalid candidate ID in excluded:&apos;, [
              [&apos;candidate candId&apos;, candId],
              [&apos;excluded list position&apos;, ix + 1],
        ]);
      }
      if (result.has(candId)) {
        throw new MeekValueError(
              &apos;Candidate ID in excluded is not unique:&apos;, [
                [&apos;candid ID&apos;, candId],
                [&apos;first list position&apos;, candidateIndexes[candId] + 1],
                [&apos;next list position&apos;, ix + 1],
        ]);
      }
      result.add(candId);
      candidateIndexes[candId] = ix;
    });
    return result;
  }

  /**
   * Validate a list of protected candidates.
   * @param {string|array&lt;string&gt;} protectedList - A proposed value.
   * @param {array&lt;string&gt;} candidates - A validated array of candidate IDs.
   * @param {Set&lt;string&gt;} excluded - A validated set of excluded candidate
   *   IDs.
   * @param {number} nbrSeatsToFill - A validated number of seats to fill.
   * @return {Set&lt;string&gt;} A set of protected candidate IDs.
   * @throw {MeekValueError} If protectedList was not valid.
   */
  protectedCandidates(protectedList, candidates, excluded, nbrSeatsToFill) {
    if (protectedList === null) {
      protectedList = [];
    }
    try {
      protectedList = Validator.toArrayOfStrings(protectedList);
    }
    catch (exc) {
      throw new MeekValueError(&apos;Invalid protectedList type:&apos;, [], exc);
    }
    const result = new Set();
    const candidateIndexes = {};
    protectedList.forEach((candId, ix) =&gt; {
      if (candidates.indexOf(candId) === -1) {
        throw new MeekValueError(&apos;Invalid protected candidate ID:&apos;, [
              [&apos;candidate ID&apos;, candId],
              [&apos;list position&apos;, ix + 1],
        ]);
      }
      if (excluded.has(candId)) {
        throw new MeekValueError(&apos;Candidate ID is protected and excluded:&apos;, [
              [&apos;candidate ID&apos;, candId],
              [&apos;protected list position&apos;, ix + 1],
        ]);
      }
      if (result.has(candId)) {
        throw new MeekValueError(
              &apos;Protected candidate ID is not unique:&apos;, [
              [&apos;candidate candId&apos;, candId],
              [&apos;first list position&apos;, candidateIndexes[candId] + 1],
              [&apos;next list position&apos;, ix + 1],
        ]);
      }
      result.add(candId);
      candidateIndexes[candId] = ix;
    });
    if (result.size &gt; nbrSeatsToFill) {
      throw new MeekValueError(
            &apos;More protected candidates than seats to fill:&apos;, [
            [&apos;nbr protected&apos;, result.size],
            [&apos;nbr seats to fill&apos;, nbrSeatsToFill],
      ]);
    }
    return result;
  }

  /**
   * Validate a plain old data object of tabulation options.
   * @param {Object} options - A proposed value.
   * @return {Object} An object with validated tabulation options,
   *   if options was valid.
   * @throw {MeekValueError} If options was not valid.
   */
  options(options) {
    const result = {};
    if (typeof options != &apos;object&apos;) {
      throw new MeekValueError(&apos;Options is not an object:&apos;, [
            [&apos;typeof options&apos;, typeof options],
      ]);
    }
    for (let name in options) {
      // The following if statement can not be true.
      /*
      if (typeof name != &apos;string&apos;) {
        throw new MeekValueError(&apos;An option name is not a string:&apos;, [
              [&apos;typeof option name&apos;, typeof name],
              [&apos;option name&apos;, name],
        ]);
      }
      */
      let value = options[name];
      if (name === K.OPTIONS.alternativeDefeats._value) {
        if (typeof value == &apos;string&apos; &amp;&amp;
              K.OPTIONS.alternativeDefeats._value_set.has(
              value.toUpperCase())) {
          value = value.toUpperCase();
        }
        else {
          try {
            value = Validator.toArrayOfStrings(value);
          }
          catch (exc) {
            throw new MeekValueError(
                  &apos;Invalid option value type:&apos;, [
                  [&apos;option name&apos;, name],
                  ], exc);
          }
          value.forEach((perRoundValue,ix) =&gt; {
            if (!K.OPTIONS.alternativeDefeats._value_set.has(
                  perRoundValue.toUpperCase())) {
              throw new MeekValueError(&apos;Invalid per-round option value:&apos;, [
                    [&apos;per-round value&apos;, perRoundValue],
                    [&apos;index&apos;, ix],
                    [&apos;for round&apos;, ix + 1],
                    [&apos;option name&apos;, name],
              ]);
            }
          });
          const newValue = [];
          value.forEach((perRoundValue, ix) =&gt; {
            newValue.push(perRoundValue.toUpperCase());
          });
          value = newValue;
        }
        result[K.OPTIONS.alternativeDefeats._value] = value;
      } else if (K.OPTIONS._value_set.has(name)) {
        const originalValue = value;
        if (typeof value == &apos;string&apos;) {
          value = value.toLowerCase();
        }
        const key = K.OPTIONS._valueToJsId[name];
        if (K.OPTIONS[key]._value_set.has(value)) {
          result[name] = value;
        } else {
          throw new MeekValueError(&apos;Invalid option value:&apos;, [
                [&apos;typeof value&apos;, typeof originalValue],
                [&apos;value&apos;, originalValue],
                [&apos;option name&apos;, name],
          ]);
        }
      } else {
        throw new MeekValueError(&apos;Invalid option name:&apos;, [
              [&apos;typeof name&apos;, typeof name],
              [&apos;name&apos;, name],
        ]);
      }
    }
    return result;
  }
}

</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
