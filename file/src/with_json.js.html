<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/with_json.js | Public API | Meeks-PRF-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Count votes for a Meek&apos;s method RCV / STV election contest using the prfound.org reference rule, with optional extensions."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/DavidCary/Meeks-PRF-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ballot.js~Ballot.html">Ballot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9.html">Decimal9</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Error.html">Decimal9Error</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/decimal9.js~Decimal9Total.html">Decimal9Total</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekImplementationError.html">MeekImplementationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors.js~MeekValueError.html">MeekValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meek.js~Tabulation.html">Tabulation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/progress.js~Progress.html">Progress</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/results.js~Results.html">Results</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/status.js~Status.html">Status</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBaseError.html">UtilBaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilBasicFunctions.html">UtilBasicFunctions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util_basic.js~UtilValueError.html">UtilValueError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/validate.js~Validator.html">Validator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/with_json.js~WithJson.html">WithJson</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tabulate">tabulate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-K">K</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UBF">UBF</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/with_json.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @copyright 2016-2019 David Cary;
 * @license Apache-2.0
 *
 * @module WithJson
 *
 * @summary Tabulate using JSON files as input and output
 */

import K from &quot;./constants.js&quot;;
import Results from &quot;./results.js&quot;;
import * as Meek from &quot;./meek.js&quot;;
import {MeekValueError, MeekImplementationError, describeError}
      from &quot;./errors.js&quot;;
import {Status} from &apos;./status.js&apos;;
import {Validator} from &apos;./validate.js&apos;;
//import Version from &apos;./index.js&apos;;

import * as fs from &apos;fs&apos;;
//import * as fsp from &apos;fs/promises&apos;;

const fsp = fs.promises;
const D9 = K.Decimal;


/** A class with static functions for tabulating with JSON files. */
class WithJson {

  /**
   * Tabulate an Meek contest using JSON files for input and output.
   *
   * This facilitates doing file-based tabulations from the command line.
   *
   * @param {string|File|null} [inputJson=&apos;&apos;]
   *   A string name of a file or an opened file that is read to get a
   *   JSON specification of the tabulation to be performed.
   *   If the value is an empty string, standard input is read.
   *   If the value is null, nothing is read.
   *
   *   The JSON specification should be a JSON object with names that
   *   correspond to the parameters of `Meek.Tabulation()`
   *   initialization.
   *
   *   Additional names may be specified.
   *   Some that are recognized include:
   *
   * - &apos;description&apos;
   *
   *    A description of the contest being tabulated.
   *
   * - &apos;include&apos;
   *
   *   An array of additional input JSON file names that are read.
   *   The name and value pairs in an included file are subject to being
   *   overridden by subsequent file names in the array of included file
   *   names and also, ultimately, by contents of the inputJson file.
   *
   *   Files can only be included by the inputJSON file.
   *   Any include value from an included file is ignored.
   *
   * @param {string|File|null} [outputJson=&apos;&apos;]
   *   A string name of a file or an opened file that is written to with a
   *   JSON specification of the tabulation results.
   *   If the value is an empty string, results are written to standard
   *   output.
   *   If the value is null, nothing is written.
   *   The JSON specification of the tabulation result is a JSON object
   *   with the following names:
   *
   * - &apos;elected&apos;
   *
   *     An array of winners, corresponding to the first value returned by
   *     Meek.Tabulation().tabulate().
   *
   * - &apos;status&apos;
   *
   *     An array of status values, each expressed as an array,
   *     corresponding to the values of the second value returned by
   *     `Meek.Tabulation().tabulate()`.
   *     The status values are listed in the following order:  candidate,
   *     status, nbrRound, votes, keepValue, and destiny.
   *     The destiny value is omitted if it is &apos;normal&apos;.
   *     Votes and keepValues are expressed as JSON numbers.
   *
   * - &apos;tally&apos;
   *
   *     An object of tally values, corresponding to the third value
   *     returned by `Meek.Tabulation().tabulate()`.
   *
   * - &apos;description&apos;
   *
   *     A string value of the input &apos;description&apos; value, if a non-empty
   *     description value string was provided.
   *     Otherwise, this name is not included in the JSON output.
   *
   * @param {string|File|null} [defaultJson=null]
   *   A str name of a file or an opened file that is read to provide
   *   default values for inputJson specification before that file is
   *   read.
   *   If the value is an empty string, standard input is read.
   *   If the value is null, no attempt to read defaults is made.
   *   If both this value and the inputJson value are empty strings,
   *   this value is treated as if it were null.
   *
   *   The JSON in the file should be a JSON object with any of the same
   *   names and values that could be used by the inputJSON file.
   *   The values in this file are overridden by corresponding values
   *   in the inputJSON file and its include files.
   *
   *   The include name is recognized from this file,
   *   but its value may be overridden by an include value
   *   specified in the inputJson file.
   *
   * @return {array}
   *
   * A two-element array consisting of the results object returned by the
   * `Meek.Tabulation().tabulate()` function,
   * and a data object with the input values built from inputJson and
   * defaultJson files and their include files.
   *
   * @throws {Error}
   *
   * The same as the `Meek.Tabulation().tabulate()` method,
   * plus other exceptions that might be related to accessing files to
   * build the tabulation specification or to store its results.
   *
   */
  static async tabulate(inputJson=&apos;&apos;, outputJson=&apos;&apos;, defaultJson=null) {
    const [tabulateArgs, tabulationSpec] = await WithJson.buildTabulateArgs(
          inputJson, defaultJson);
    let description = null;
    if (&apos;description&apos; in tabulationSpec) {
      description = tabulationSpec.description;
    }
    const results = new Meek.Tabulation(...tabulateArgs)
          .tabulate();
    const jsonStr = WithJson.resultsToJsonString(
          results, description);
    await WithJson.writeFile(outputJson, jsonStr);
    return [results, tabulationSpec];
  }

  /**
   * Convert tabulation results to a JSON string.
   *
   * @param {Results} results
   *   The results returned by the `Meek.Tabulation.tabulate()` function.
   *
   * @param {string|null|boolean} description
   *   A string that is that describes the tabulation.
   *   This is typically supplied from the tabulation&apos;s input
   *   specification or from the value returned by this module&apos;s
   *   `tabulate()` function.
   *   Values of null and false may be supplied to indicate the lack
   *   of a description.
   *
   * @return {string}
   * A JSON string which represents the function arguments.
   *
   * @throws {Error}
   * This can raise various exceptions if the function arguments are not
   * of the anticipated structure.
   */
  static resultsToJsonString(results, description) {
    let descriptionStr = &apos;&apos;;
    if (description !== null) {
      descriptionStr = &apos;  &quot;description&quot;: &apos; + JSON.stringify(description);
      descriptionStr += &apos;\n&apos;;
    }

    const electedStr = results.getElectedAsString(description ? &apos;,&apos; : &apos;&apos;) +
          &apos;\n&apos;;
    const statusStr = results.getStatusesAsString(&apos;,&apos;) +
          &apos;\n&apos;;
    const tallyStr = results.getTallyAsString(&apos;,&apos;) + &apos;\n&apos;;
    const jsonStr = &apos;{\n&apos; +
          descriptionStr + electedStr + statusStr + tallyStr + &apos;}\n&apos;
    return jsonStr;
  }

  /**
   * From JSON files, build tabulation args and specification.
   *
   * @param {string|File|null} inputJson
   * The same as for the inputJson parameter for this module&apos;s
   * `tabulate()` function.
   *
   * @param {string|File|null} defaultJson
   * The same as for the defaultJson parameter for this module&apos;s
   * `tabulate()` function.
   *
   * @return {array}
   * An array with tw values:
   *
   * + An array of tabulation args that can be passed to
   *     `Meek.Tabulation().tabulate()`
   *
   * + A data object with the aggregated input for a Meek tabulation.
   *   Additional keys and values may be ignored or used only for testing.
   *
   * @throws {Error}
   * Various exceptions may be thrown which are related to reading JSON
   * files.
   */
  static async buildTabulateArgs(inputJson, defaultJson) {

    const tabulationSpec = await WithJson.readTabulationSpec(
          inputJson, defaultJson);
    let argBallots = tabulationSpec[&apos;ballots&apos;];
    if (&apos;ballotsMore&apos; in tabulationSpec) {
      argBallots = Array.from(argBallots);
      argBallots = argBallots.concat(
            Array.from(tabulationSpec[&apos;ballotsMore&apos;]));
    }
    const tabulateArgs = [
          tabulationSpec[&apos;nbrSeatsToFill&apos;],
          tabulationSpec[&apos;candidates&apos;],
          argBallots,
          tabulationSpec[&apos;maxRankingLevels&apos;],
          tabulationSpec[&apos;tieBreaker&apos;],
          tabulationSpec[&apos;excluded&apos;],
          tabulationSpec[&apos;protected&apos;],
          tabulationSpec[&apos;options&apos;]
          ];
    return [tabulateArgs, tabulationSpec];
  }

  /**
   * Write text to a file.
   *
   * @param {string|File|null} fileName
   * The name of the file to write to.
   *
   * Write to stdout if this is the empty string.
   *
   * @param {string} text
   * The text to be written.
   *
   * @throws {Error}
   * Various exceptions related to writing to a file.
   */
  static async writeFile(fileName, text) {
    if (fileName == &apos;&apos;) {
      process.stdout.write(text);
    } else if (fileName === null) {
    } else {
      await new Promise((resolve, reject) =&gt; {
        fs.writeFile(fileName, text, &apos;utf8&apos;, (err) =&gt; {
          if (err) {
            reject(err);
          } else {
            resolve(true);
          }
        });
      }).then((data) =&gt; {
        return data;
      });
    }
  }

  /**
   * Read text from a file.
   *
   * @param {string|File|null} fileName
   * The name of the file to read from.
   *
   * Read from stdin if this is the empty string.
   *
   * @return {string}
   * The text that was read.
   *
   * @throws {Error}
   * Various exceptions related to reading from a file.
   */
  static async readFile(fileName) {
    let text = &apos;&apos;;
    //console.debug(fs);
    if (fileName == &apos;&apos;) {
      text = fs.readFileSync(0, &apos;utf8&apos;);
    } else if (fileName === null) {
    } else {
      let readPromise = new Promise(async (resolve, reject) =&gt; {
        fs.readFile(fileName, &apos;utf8&apos;, (err, data) =&gt; {
          if (err) {
            reject(err);
          }
          resolve(data);
        });
      });
      text = await readPromise;
      //await console.debug(&apos;readFile text set with await&apos;);
      /*
      .then(data =&gt; {
        text = data;
        console.debug(&apos;setting readFile text with then&apos;);
        //console.debug(&apos;readFile text=&quot;&apos;+text+&apos;&quot;&lt;&lt;&lt;&apos;);
      });
      */
    }
    //await console.debug(&apos;returning readFile text&apos;);
    return text;
  }

  /**
   * Read text from a file and parse it as JSON data.
   *
   * @param {string|File|null} fileName
   * The name of the file to read from.
   *
   * Read from stdin if this is the empty string.
   *
   * @return {*}
   * The data value parsed from JSON text that was read.
   *
   * @throws {Error}
   * Various exceptions related to reading from a file and parsing it
   * as JSON data.
   */
  static async readJson(fileName) {
    const text = await WithJson.readFile(fileName);
    //console.debug(&apos;readJson text=&apos;+Meek._show(text));
    if (text == &apos;&apos;) {
      return {};
    }
    const jsonResult = JSON.parse(text);
    return jsonResult;
  }

  /**
   * Optionally read text from a file and parse it as JSON data.
   *
   * If the file does not exist return an empty JSON object.
   *
   * @param {string} fileName
   * The name of the file to read from, if it exists
   *
   * @return {*}
   * The data value parsed from JSON text that was read,
   * or an empty data object if the file does not exist.
   *
   * @throws {Error}
   * Various exceptions related to reading from a file and parsing it
   * as JSON data.
   */
  static async readOptionalJson(fileName) {
    const result = {};
    if (typeof fileName == &apos;string&apos; &amp;&amp; fileName != &apos;&apos; &amp;&amp;
          fs.existsSync(fileName)) {
      const fileResult = await WithJson.readJson(fileName);
      Object.assign(result, fileResult);
    }
    return result;
  }

  /**
   * From JSON files, read the tabulation specification.
   *
   * The order of building test specs, with later values overriding earlier
   * values:
   *
   * - hard-coded default values
   * - values in the defaultJson file
   * - values from the included files in the order listed
   * - values from the inputJson file
   *
   * However, a list of include files is only taken from the primary JSON
   * file.
   *
   * @param {string|File|null} inputJson
   * The same as for the inputJson parameter for this module&apos;s
   * `tabulate()` function.
   *
   * @param {string|File|null} defaultJson
   * The same as for the defaultJson parameter for this module&apos;s
   * `tabulate()` function.
   *
   * @return {Object}
   * A data object with the merged tabulation specification.
   *
   * @throws {Error}
   * Various exceptions may be thrown which are related to reading JSON
   * files.
   */
  static async readTabulationSpec(inputJson, defaultJson) {
    const tabulationSpec = {
          &apos;description&apos;: &apos;Test description not provided.&apos;,
          &apos;nbrSeatsToFill&apos;: 0,
          &apos;candidates&apos;: &apos;&apos;,
          &apos;ballots&apos;: [],
          &apos;maxRankingLevels&apos;: 0,
          &apos;tieBreaker&apos;: &apos;&apos;,
          &apos;options&apos;: {},
          &apos;elected&apos;: &apos;&apos;,
          &apos;statusCodes&apos;: [],
          &apos;tally&apos;: {},
          &apos;excluded&apos;: [],
          &apos;protected&apos;: [],
          };
    if (defaultJson !== null &amp;&amp; defaultJson !== undefined &amp;&amp;
          !(defaultJson == &apos;&apos; &amp;&amp; inputJson == &apos;&apos;)) {
      const defaultSpec = await WithJson.readOptionalJson(defaultJson);
      Object.assign(tabulationSpec, defaultSpec);
    }
    /*
    */
    const primarySpec = await WithJson.readJson(inputJson);
    //console.debug(&apos;primarySpec=&apos;+Meek._show(primarySpec));
    let includeList = [];
    if (&apos;include&apos; in primarySpec) {
      includeList = primarySpec[&apos;include&apos;];
    }
    //console.debug(&apos;includeList=&apos;+Meek._show(includeList));
    //await includeList.forEach(async (includeInputJson) =&gt; {
    for (let iix in includeList) {
      const includeInputJson = includeList[iix];
      //console.debug(&apos;iix=&apos;+iix+&apos; includeInputJson=&apos;+includeInputJson);
      const includeSpec = await WithJson.readJson(includeInputJson);
      Object.assign(tabulationSpec, includeSpec);
    }  //);
    /*
    */
    Object.assign(tabulationSpec, primarySpec);
    return tabulationSpec;
  }

  /**
   * Tabulate using command-line argument JSON file names
   *
   * First check whether the module appears to be running under Node,
   * so that Node&apos;s `process.argv` array can be used to retrieve
   * the command line arguments.
   */
  static cliTabulate() {
    if (process &amp;&amp; process.argv &amp;&amp;
          Array.isArray(process.argv) &amp;&amp;
      process.argv.length &gt;= 2) {
      if (process.argv.length &gt; 3) {
        WithJson.tabulate(process.argv[2], process.argv[3]);
      } else if (process.argv.length &gt; 2) {
        if (process.argv[2] === &apos;--version&apos;) {
          process.stdout.write(&apos;Version &apos; + K.VERSION_STRING + &apos;\n&apos;);
        } else {
          WithJson.tabulate(process.argv[2], &apos;&apos;);
        }
      }
    }
  }

}

export default WithJson;

/* Check whether this module is the top level module running in Node,
 * and if so, do a JSON file-based tabulation
 * using the command-line arguments.
 */
if (require &amp;&amp; require.main &amp;&amp; module &amp;&amp;
      require.main === module &amp;&amp;
      process &amp;&amp; process.argv &amp;&amp;
      Array.isArray(process.argv) &amp;&amp; process.argv.length &gt;= 2) {
  WithJson.cliTabulate();
}

</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
